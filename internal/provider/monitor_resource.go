// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/pete-leese/terraform-provider-ukumawapi/internal/sdk"
	"github.com/pete-leese/terraform-provider-ukumawapi/internal/sdk/models/operations"
	"github.com/pete-leese/terraform-provider-ukumawapi/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &MonitorResource{}
var _ resource.ResourceWithImportState = &MonitorResource{}

func NewMonitorResource() resource.Resource {
	return &MonitorResource{}
}

// MonitorResource defines the resource implementation.
type MonitorResource struct {
	client *sdk.TerraformProviderUkumawapi
}

// MonitorResourceModel describes the resource data model.
type MonitorResourceModel struct {
	AcceptedStatuscodes      []types.String `tfsdk:"accepted_statuscodes"`
	AuthDomain               types.String   `tfsdk:"auth_domain"`
	AuthMethod               types.String   `tfsdk:"auth_method"`
	AuthWorkstation          types.String   `tfsdk:"auth_workstation"`
	BasicAuthPass            types.String   `tfsdk:"basic_auth_pass"`
	BasicAuthUser            types.String   `tfsdk:"basic_auth_user"`
	Body                     types.String   `tfsdk:"body"`
	Data                     types.String   `tfsdk:"data"`
	DatabaseConnectionString types.String   `tfsdk:"database_connection_string"`
	DatabaseQuery            types.String   `tfsdk:"database_query"`
	DNSResolveServer         types.String   `tfsdk:"dns_resolve_server"`
	DNSResolveType           types.String   `tfsdk:"dns_resolve_type"`
	DockerContainer          types.String   `tfsdk:"docker_container"`
	DockerHost               types.Int64    `tfsdk:"docker_host"`
	ExpiryNotification       types.Bool     `tfsdk:"expiry_notification"`
	Headers                  types.String   `tfsdk:"headers"`
	Hostname                 types.String   `tfsdk:"hostname"`
	IgnoreTLS                types.Bool     `tfsdk:"ignore_tls"`
	Interval                 types.Int64    `tfsdk:"interval"`
	Keyword                  types.String   `tfsdk:"keyword"`
	Maxredirects             types.Int64    `tfsdk:"maxredirects"`
	Maxretries               types.Int64    `tfsdk:"maxretries"`
	Method                   types.String   `tfsdk:"method"`
	MonitorID                types.Int64    `tfsdk:"monitor_id"`
	MqttPassword             types.String   `tfsdk:"mqtt_password"`
	MqttSuccessMessage       types.String   `tfsdk:"mqtt_success_message"`
	MqttTopic                types.String   `tfsdk:"mqtt_topic"`
	MqttUsername             types.String   `tfsdk:"mqtt_username"`
	Name                     types.String   `tfsdk:"name"`
	NotificationIDList       []types.String `tfsdk:"notification_id_list"`
	Port                     types.Int64    `tfsdk:"port"`
	ProxyID                  types.Int64    `tfsdk:"proxy_id"`
	RadiusCalledStationID    types.String   `tfsdk:"radius_called_station_id"`
	RadiusCallingStationID   types.String   `tfsdk:"radius_calling_station_id"`
	RadiusPassword           types.String   `tfsdk:"radius_password"`
	RadiusSecret             types.String   `tfsdk:"radius_secret"`
	RadiusUsername           types.String   `tfsdk:"radius_username"`
	ResendInterval           types.Int64    `tfsdk:"resend_interval"`
	RetryInterval            types.Int64    `tfsdk:"retry_interval"`
	Type                     types.String   `tfsdk:"type"`
	UpsideDown               types.Bool     `tfsdk:"upside_down"`
	URL                      types.String   `tfsdk:"url"`
}

func (r *MonitorResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_monitor"
}

func (r *MonitorResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Monitor Resource",
		Attributes: map[string]schema.Attribute{
			"accepted_statuscodes": schema.ListAttribute{
				Optional:    true,
				ElementType: types.StringType,
				Validators: []validator.List{
					listvalidator.ValueStringsAre(validators.IsValidJSON()),
				},
			},
			"auth_domain": schema.StringAttribute{
				Optional: true,
			},
			"auth_method": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Default:     stringdefault.StaticString(""),
				Description: `Enumerate authentication methods for monitors. Default: ""; must be one of ["", "basic", "ntlm", "mtls"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"basic",
						"ntlm",
						"mtls",
					),
				},
			},
			"auth_workstation": schema.StringAttribute{
				Optional: true,
			},
			"basic_auth_pass": schema.StringAttribute{
				Optional: true,
			},
			"basic_auth_user": schema.StringAttribute{
				Optional: true,
			},
			"body": schema.StringAttribute{
				Optional: true,
			},
			"data": schema.StringAttribute{
				Computed:    true,
				Description: `Parsed as JSON.`,
				Validators: []validator.String{
					validators.IsValidJSON(),
				},
			},
			"database_connection_string": schema.StringAttribute{
				Optional: true,
			},
			"database_query": schema.StringAttribute{
				Optional: true,
			},
			"dns_resolve_server": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Default:     stringdefault.StaticString("1.1.1.1"),
				Description: `Default: "1.1.1.1"`,
			},
			"dns_resolve_type": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Default:     stringdefault.StaticString("A"),
				Description: `Default: "A"`,
			},
			"docker_container": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Default:     stringdefault.StaticString(""),
				Description: `Default: ""`,
			},
			"docker_host": schema.Int64Attribute{
				Optional: true,
			},
			"expiry_notification": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Default:     booldefault.StaticBool(false),
				Description: `Default: false`,
			},
			"headers": schema.StringAttribute{
				Optional: true,
			},
			"hostname": schema.StringAttribute{
				Optional: true,
			},
			"ignore_tls": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Default:     booldefault.StaticBool(false),
				Description: `Default: false`,
			},
			"interval": schema.Int64Attribute{
				Computed:    true,
				Optional:    true,
				Default:     int64default.StaticInt64(60),
				Description: `Default: 60`,
			},
			"keyword": schema.StringAttribute{
				Optional: true,
			},
			"maxredirects": schema.Int64Attribute{
				Computed:    true,
				Optional:    true,
				Default:     int64default.StaticInt64(10),
				Description: `Default: 10`,
			},
			"maxretries": schema.Int64Attribute{
				Computed:    true,
				Optional:    true,
				Default:     int64default.StaticInt64(0),
				Description: `Default: 0`,
			},
			"method": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Default:     stringdefault.StaticString("GET"),
				Description: `Default: "GET"`,
			},
			"monitor_id": schema.Int64Attribute{
				Required: true,
			},
			"mqtt_password": schema.StringAttribute{
				Optional: true,
			},
			"mqtt_success_message": schema.StringAttribute{
				Optional: true,
			},
			"mqtt_topic": schema.StringAttribute{
				Optional: true,
			},
			"mqtt_username": schema.StringAttribute{
				Optional: true,
			},
			"name": schema.StringAttribute{
				Required: true,
			},
			"notification_id_list": schema.ListAttribute{
				Optional:    true,
				ElementType: types.StringType,
				Validators: []validator.List{
					listvalidator.ValueStringsAre(validators.IsValidJSON()),
				},
			},
			"port": schema.Int64Attribute{
				Computed:    true,
				Optional:    true,
				Default:     int64default.StaticInt64(53),
				Description: `Default: 53`,
			},
			"proxy_id": schema.Int64Attribute{
				Optional: true,
			},
			"radius_called_station_id": schema.StringAttribute{
				Optional: true,
			},
			"radius_calling_station_id": schema.StringAttribute{
				Optional: true,
			},
			"radius_password": schema.StringAttribute{
				Optional: true,
			},
			"radius_secret": schema.StringAttribute{
				Optional: true,
			},
			"radius_username": schema.StringAttribute{
				Optional: true,
			},
			"resend_interval": schema.Int64Attribute{
				Computed:    true,
				Optional:    true,
				Default:     int64default.StaticInt64(0),
				Description: `Default: 0`,
			},
			"retry_interval": schema.Int64Attribute{
				Computed:    true,
				Optional:    true,
				Default:     int64default.StaticInt64(60),
				Description: `Default: 60`,
			},
			"type": schema.StringAttribute{
				Required:    true,
				Description: `Enumerate monitor types. must be one of ["http", "port", "ping", "keyword", "grpc-keyword", "dns", "docker", "push", "steam", "gamedig", "mqtt", "sqlserver", "postgres", "mysql", "mongodb", "radius", "redis"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"http",
						"port",
						"ping",
						"keyword",
						"grpc-keyword",
						"dns",
						"docker",
						"push",
						"steam",
						"gamedig",
						"mqtt",
						"sqlserver",
						"postgres",
						"mysql",
						"mongodb",
						"radius",
						"redis",
					),
				},
			},
			"upside_down": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Default:     booldefault.StaticBool(false),
				Description: `Default: false`,
			},
			"url": schema.StringAttribute{
				Optional: true,
			},
		},
	}
}

func (r *MonitorResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.TerraformProviderUkumawapi)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.TerraformProviderUkumawapi, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *MonitorResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *MonitorResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := *data.ToSharedSchemasMonitorMonitor()
	res, err := r.client.Monitor.Create(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Any != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromInterface(res.Any)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	res1, err := r.client.Monitor.GetAll(ctx)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.Any != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromInterface(res1.Any)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *MonitorResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *MonitorResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	res, err := r.client.Monitor.GetAll(ctx)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Any != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromInterface(res.Any)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *MonitorResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *MonitorResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	var monitorID int64
	monitorID = data.MonitorID.ValueInt64()

	monitorUpdate := *data.ToSharedMonitorUpdate()
	request := operations.UpdateMonitorMonitorsMonitorIDPatchRequest{
		MonitorID:     monitorID,
		MonitorUpdate: monitorUpdate,
	}
	res, err := r.client.Monitors.Update(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Any != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromInterface(res.Any)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	res1, err := r.client.Monitor.GetAll(ctx)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.Any != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromInterface(res1.Any)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *MonitorResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *MonitorResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var monitorID int64
	monitorID = data.MonitorID.ValueInt64()

	request := operations.DeleteMonitorMonitorsMonitorIDDeleteRequest{
		MonitorID: monitorID,
	}
	res, err := r.client.Monitor.Delete(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *MonitorResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.AddError("Not Implemented", "No available import state operation is available for resource monitor.")
}
